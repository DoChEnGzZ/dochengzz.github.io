<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++实现小顶堆和大顶堆</title>
    <url>/2021/03/08/c-%E5%AE%9E%E7%8E%B0%E5%B0%8F%E9%A1%B6%E5%A0%86%E5%92%8C%E5%A4%A7%E9%A1%B6%E5%A0%86/</url>
    <content><![CDATA[<h1 id="小顶堆和大顶堆"><a href="#小顶堆和大顶堆" class="headerlink" title="小顶堆和大顶堆"></a>小顶堆和大顶堆</h1><span id="more"></span>

<h2 id="什么是小顶堆和大顶堆"><a href="#什么是小顶堆和大顶堆" class="headerlink" title="什么是小顶堆和大顶堆"></a>什么是小顶堆和大顶堆</h2><p>堆是一种<strong>非线性结构</strong>，可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲<strong>堆其实就是利用完全二叉树的结构来维护的一维数组</strong>。</p>
<p>按照堆的特点可以把堆分为<strong>大顶堆</strong>和<strong>小顶堆</strong>。</p>
<p>大顶堆：每个结点的值都<strong>大于</strong>或<strong>等于</strong>其左右孩子结点的值。</p>
<p>小顶堆：每个结点的值都<strong>小于</strong>或<strong>等于</strong>其左右孩子结点的值。</p>
<p>（堆的这种特性非常的有用，堆常常被当做优先队列使用，因为可以快速的访问到“最重要”的元素）</p>
<img src="https://i.loli.net/2021/03/09/9tk6zaVicMxnGZr.png" alt="image.png" style="zoom:50%;" />

<p>我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p>
<img src="/Users/apple/Library/Application Support/typora-user-images/image-20210309145219125.png" alt="image-20210309145219125" style="zoom:50%;" />

<p>我们用简单的公式来描述一下堆的定义就是：</p>
<p><strong>大顶堆：</strong>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] </p>
<p><strong>小顶堆：</strong>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] </p>
<p>所以利用堆的数据结构，可以将序列中最大或者最小的元素不断输出出来，这样实现了排序的目的，常用来构造哈夫曼树。</p>
<h2 id="堆排序的过程"><a href="#堆排序的过程" class="headerlink" title="堆排序的过程"></a>堆排序的过程</h2><p>先了解下<strong>堆排序</strong>的基本思想：</p>
<p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值，</p>
<p>如此反复执行，便能得到一个有序序列了，建立最大堆时是从<strong>最后一个非叶子节点</strong>开始从下往上调整的（对应到数组中即是n/2的位置，真好为第一个非叶子结点）。</p>
<h2 id="c-中小顶堆和大顶堆的实现"><a href="#c-中小顶堆和大顶堆的实现" class="headerlink" title="c++中小顶堆和大顶堆的实现"></a>c++中小顶堆和大顶堆的实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; big;　　　　<span class="comment">// 大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; small;　　<span class="comment">// 小顶堆</span></span><br><span class="line">big.<span class="built_in">push</span>(x); <span class="comment">//push操作，将新元素插入堆并进行堆的调整</span></span><br><span class="line"><span class="type">int</span> x=big.<span class="built_in">top</span>(); <span class="comment">//pop操作，将堆顶的元素弹出堆，即最大或最小元素</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令记录</title>
    <url>/2021/04/07/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>简易版git使用指南，记性太差老是忘记这些命令又要重新查，所以记在自己博客里方便查看。</p>
<span id="more"></span>

<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone username@host:/path/to/repositor</span><br></pre></td></tr></table></figure>

<h2 id="添加文件到本地缓存区"><a href="#添加文件到本地缓存区" class="headerlink" title="添加文件到本地缓存区"></a>添加文件到本地缓存区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h2 id="提交文件到本地仓库"><a href="#提交文件到本地仓库" class="headerlink" title="提交文件到本地仓库"></a>提交文件到本地仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure>

<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<h2 id="更新本地仓库"><a href="#更新本地仓库" class="headerlink" title="更新本地仓库"></a>更新本地仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制数</title>
    <url>/2021/03/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<p><strong>题目描述</strong></p>
<blockquote>
<p>大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。</p>
</blockquote>
<span id="more"></span>

<p><strong>输入</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多行，每一行表示要求的数字</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>输出</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出共T行。每行输出求得的二进制串。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>示例</strong></p>
<p>输入：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23</span><br><span class="line">535</span><br><span class="line">2624</span><br><span class="line">56275</span><br><span class="line">989835</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10111</span><br><span class="line">1000010111</span><br><span class="line">101001000000</span><br><span class="line">1101101111010011</span><br><span class="line">11110001101010001011</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num,mod,count;</span><br><span class="line">  <span class="comment">//核心思想除2取余得二进制结果</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;num)&#123;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">      <span class="comment">//用数组存储除2取余的结果</span></span><br><span class="line">        <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">      <span class="comment">//如果输入数据为1则直接输出</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//循环除2取余</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[count++]=num%<span class="number">2</span>;</span><br><span class="line">            num=num/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//逆序输出，为二进制结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=count<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前言</title>
    <url>/2021/01/27/%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<span id="more"></span>

<p>  时间来到2021年1月，考研刚刚结束，结果尚未可知，学业与生活双双不顺，因此使用<code>hexo</code>和<code>github</code>搭建此博客用于记录学习和阅读的过程，<del>希望在春招能获得理想的结果</del>。</p>
<p>考研成功上岸哈哈哈哈</p>
<p>  本博客不指望有观众，只求多年后看到自己的学习经历能一笑置之。如果有某位观众老爷碰巧进入我的博客，也感谢您的大驾光临，令本地蓬荜生辉。</p>
<p> 正在努力把之前博客园的文章搬过来，进度缓慢。。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的命令</title>
    <url>/2022/11/16/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>



<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用hexo搭建博客</title>
    <url>/2021/01/30/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p>
<span id="more"></span>





<h2 id="1-使用github的仓库提供服务器"><a href="#1-使用github的仓库提供服务器" class="headerlink" title="1 使用github的仓库提供服务器"></a>1 使用github的仓库提供服务器</h2><p>创建仓库的名字必须为<strong>username.github.io</strong>，我的用户名为dochengzz，因此我创建的仓库就是<strong>do cengzz.github.io</strong>，这是很关键的一点，很重要。输入名字后，直接点最下面绿色的按钮，创建新仓库。这一部分基本完成了，接下去需要在终端操作。</p>
<img src="https://i.loli.net/2021/03/07/Fa16qBrzuGkOoe8.png" alt="image.png" style="zoom: 50%;" />



<h2 id="2-本地工作"><a href="#2-本地工作" class="headerlink" title="2 本地工作"></a>2 本地工作</h2><h3 id="2-1-安装Node-js与Git"><a href="#2-1-安装Node-js与Git" class="headerlink" title="2.1 安装Node.js与Git"></a>2.1 安装Node.js与Git</h3><p><a href="https://nodejs.org/en/">Node.js</a></p>
<p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者<a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li>
<li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li>
<li>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a></li>
</ul>
<p><a href="http://git-scm.com/">Git</a></p>
<ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li>
<li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<h3 id="2-2-安装Hexo"><a href="#2-2-安装Hexo" class="headerlink" title="2.2 安装Hexo"></a>2.2 安装Hexo</h3><ul>
<li>如果已经安装好了上述的软件，那么可以安装hexo，然后等待安装成功即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>创建blog文件夹，并初始化建立博客框架</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在你的家目录下创建一个blog文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> blog</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 初始化目录</span></span><br><span class="line">hexo init</span><br><span class="line">开启本地服务 </span><br><span class="line"><span class="comment"># hexo s</span></span><br></pre></td></tr></table></figure>

<ul>
<li>出现以下信息，说明你可以本地访问博客系统，在浏览器输入4000这个网址，就可以看到博客首页。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appledeMacBook-Pro-2:hexo apple$ hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/07/8zKIvdLUnqVZ76e.png" alt="image.png" style="zoom:50%;" />

<h3 id="2-3-将hexo关联到github仓库"><a href="#2-3-将hexo关联到github仓库" class="headerlink" title="2.3 将hexo关联到github仓库"></a>2.3 将hexo关联到github仓库</h3><ul>
<li>首先我们要编辑博客目录中的<code>_config.yml</code>文件，这是博客的主要配置文件，在创建博客的过程中我们需要频繁控制这个配置文件，这里先编辑一步，为了管理GitHub账号。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根目录内容如下，其中_config.yml即为</span></span><br><span class="line">appledeMacBook-Pro-2:hexo apple$ ls</span><br><span class="line">_config.landscape.yml	db.json			package-lock.json	public			source</span><br><span class="line">_config.yml		node_modules		package.json		scaffolds		themes</span><br></pre></td></tr></table></figure>

<ul>
<li>打开文件之后，在文档如下位置，输入如下内容，只需要将你的username替换就可以了，其他无需更改。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Deployment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:dochengzz/dochengzz.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在目录中执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 产生静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 部署到GitHub page上</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后你需要输入你GitHub的用户名和密码，这样你就就可以使用你的仓库名去访问你的博客主页了。为了每一次部署不必一种输入密码，我们可以生成秘钥，然后提交到GitHub，进行关联，那么你下次就不需要再输入密码了。</p>
<ul>
<li>关联GitHub账号，免密提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用你注册GitHub时的邮箱号，进行秘钥生成</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxxxx@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 系统就会生成一个隐藏文件夹.ssh</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 复制公钥</span></span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>点击箭头的按钮，进入设置，然后点击SSH and GPG keys，创建新的SSH，将之前复制的公钥黏贴，提交，OK。</p>
<img src="https://i.loli.net/2021/03/07/76xEVgk12BCeh8L.png" alt="image.png" style="zoom:50%;" />

<h2 id="3-博客的使用"><a href="#3-博客的使用" class="headerlink" title="3 博客的使用"></a>3 博客的使用</h2><p>有时间更新下换主题、怎么写博客、怎么创建评论系统等等教程。。</p>
<p>我的主题：<a href="http://theme-next.iissnan.com/getting-started.html">Next</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>当我谈跑步时我谈些什么1</title>
    <url>/2021/04/27/%E5%BD%93%E6%88%91%E8%B0%88%E8%B7%91%E6%AD%A5%E6%97%B6%E6%88%91%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%881/</url>
    <content><![CDATA[<p>作为一个同样热爱跑步的人，我早已经对村上春树的《当我谈跑步时我谈些什么》很感兴趣了，人与人之间对事情的看法不尽相同，但是总能从别人的想法中得到些什么。这篇博客会记录我感触很深的话。</p>
<span id="more"></span>

<h3 id="第二章-人是如何成为跑步小说家的"><a href="#第二章-人是如何成为跑步小说家的" class="headerlink" title="第二章 人是如何成为跑步小说家的"></a>第二章 人是如何成为跑步小说家的</h3><blockquote>
<p>不过细想起来，这种生来容易发胖的体质或许是一种幸运。比如说，我这种人为了不增加体重，每天得剧烈的运动，留意饮食有所节制。何等浪费的人生啊！但倘若从不偷懒，坚持努力，代谢便可以维持在高水平，身体愈来愈健壮，老化恐怕也会减缓。什么都不做也不发胖的人无需留意运动和饮食。并无必要却去寻这种麻烦事儿做的人肯定也不会太多，因此这种体质的人，体力每每随着年龄增长而衰退。不着意锻炼的话，肌肉自然而然便会松弛，骨质变回疏松。阅读此文的读者，也许有人抱有这样的烦恼：”啊呀呀，一不小心体重马上就增加“应当用积极正面的思考，将这件事视为上天赐予的好运。不过这么去思考问题也不容易。</p>
</blockquote>
<p>以后谁和我抱怨他长胖了我就这么劝他（包括我自己</p>
]]></content>
      <categories>
        <category>春上村树</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2021/03/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ul>
<li><p>1．先从数列中取出一个数作为基准数。</p>
</li>
<li><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p>
</li>
<li><p>3．再对左右区间重复第二步，直到各区间只有一个数。  </p>
</li>
</ul>
<p>快速排序利用分治法，时间复杂度为O(logn)，不稳定，原序列越混乱越排序所花时间越多。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//将数组的第一个元素作为基准元素flag</span></span><br><span class="line">  <span class="comment">//一趟排序完让比flag大的元素位于flag左边，比flag小的元素位于flag右边</span></span><br><span class="line">    <span class="type">int</span> flag=a[low];</span><br><span class="line">    <span class="type">int</span> i=low,j=high;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//每次找到左边一个比flag大的元素，右边一个比flag小的元素</span></span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=flag&amp;&amp;j&gt;i)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=flag&amp;&amp;j&gt;i)</span><br><span class="line">            i++;</span><br><span class="line">      <span class="comment">//将二者交换</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//将基准元素flag放到中间，实质是一次交换</span></span><br><span class="line">    <span class="type">int</span> temp=a[i];</span><br><span class="line">    a[i]=flag;</span><br><span class="line">    a[low]=temp;</span><br><span class="line">  <span class="comment">//对左边和右边进行递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a,low,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组翻转</title>
    <url>/2021/03/21/%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>首先输入一个5 * 5的数组，然后输入一行，这一行有四个数，前两个代表操作类型，后两个数x y代表需操作数据为以x y为左上角的那几个数据。 操作类型有四种： 1 2 表示：90度，顺时针，翻转4个数 1 3 表示：90度，顺时针，翻转9个数 2 2 表示：90度，逆时针，翻转4个数 2 3 表示：90度，逆时针，翻转9个数 </p>
<span id="more"></span>

<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组输入一个5 * 5的数组，然后输入一行，这一行有四个数，前两个代表操作类型，后两个数x y代表需操作数据为以x y为左上角的那几个数据。</span><br></pre></td></tr></table></figure>

<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出翻转后的数组。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">6 7 8 9 10</span><br><span class="line">11 12 13 14 15</span><br><span class="line">16 17 18 19 20</span><br><span class="line">21 22 23 24 25</span><br><span class="line">1 3 1 1</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 6 1 4 5</span><br><span class="line">12 7 2 9 10</span><br><span class="line">13 8 3 14 15</span><br><span class="line">16 17 18 19 20</span><br><span class="line">21 22 23 24 25</span><br></pre></td></tr></table></figure>



<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题自己没想出来，看了牛客网上别人分享的题解，才有了解题思路，关键在于翻转公式，即一个坐标(x,y)围绕另一个坐标(rx,ry)旋转\theta度后的坐标(x<sub>0</sub>,y<sub>0</sub>)。</p>
<p>公式如下：</p>
<blockquote>
<p><img src="https://www.nowcoder.com/equation?tex=x_0=%20(x%20-%20rx)*cos(a)%20-%20(y%20-%20ry)*sin(a)%20+%20rx%20;&preview=true" alt="img"></p>
<p><img src="https://www.nowcoder.com/equation?tex=y_0=%20(x%20-%20rx)*sin(a)%20+%20(y%20-%20ry)*cos(a)%20+%20ry;&preview=true" alt="img"></p>
</blockquote>
<p>顺时针旋转90度时，sin(a)为1，cos(a)为0，逆时针旋转90度时，sin(a)为-1，cos(a)为0。当旋转4个数时，旋转中心的坐标为(x+0.5,y+0.5),当旋转9个数时，旋转中心的坐标为(x+1,y+1)。这样带入公式可以得到对应的旋转公式。</p>
<p>顺时针：</p>
<blockquote>
<p>​                                                   x<sub>0</sub>=rx+ry+num-1-y</p>
<p>​                                                   y<sub>0</sub>=x+ry-rx</p>
</blockquote>
<p>逆时针：</p>
<blockquote>
<p>​                                                  x<sub>0</sub>=rx-ry+y</p>
<p>​                                                   y<sub>0</sub>=x+y+num-1-i</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="type">int</span> a[SIZE][SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">int</span> a[SIZE][SIZE],<span class="type">int</span> op1,<span class="type">int</span> op2,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num,direction; <span class="comment">//num记录翻转的子数组大小，direction记录翻转方向，0为顺时针，1为逆时针</span></span><br><span class="line">    <span class="type">int</span> b[SIZE][SIZE]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(op1==<span class="number">1</span>)</span><br><span class="line">        direction=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        direction=<span class="number">1</span>;</span><br><span class="line">    num = op2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=SIZE;j++)</span><br><span class="line">            <span class="keyword">if</span>((i&gt;=x&amp;&amp;j&gt;=y)&amp;&amp;(i&lt;=x+num<span class="number">-1</span>)&amp;&amp;j&lt;=y+num<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(direction)<span class="comment">//逆时针</span></span><br><span class="line">                &#123;</span><br><span class="line">                    b[x+y+num<span class="number">-1</span>-j][i+y-x]=a[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//顺时针</span></span><br><span class="line">                &#123;</span><br><span class="line">                    b[x-y+j][x+y+num<span class="number">-1</span>-i]=a[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                b[i][j]=a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a,b,<span class="built_in">sizeof</span> (b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> op1,op2,x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j&lt;=SIZE; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;op1&gt;&gt;op2&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="built_in">Rotate</span>(a,op1,op2,x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=SIZE;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>斗地主打牌算大小</title>
    <url>/2021/03/25/%E6%96%97%E5%9C%B0%E4%B8%BB%E6%89%93%E7%89%8C%E7%AE%97%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牌只有1到9，手里拿着已经排好序的牌a，对方出牌b，用程序判断手中牌是否能够压过对方出牌。 规则：出牌牌型有5种  [1]一张 如4 则5…9可压过 [2]两张 如44 则55，66，77，…，99可压过 [3]三张 如444 规则如[2] [4]四张 如4444 规则如[2] [5]五张 牌型只有12345 23456 34567 45678 56789五个，后面的比前面的均大。</p>
<span id="more"></span>

<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组输入两个字符串(字符串大小不超过100)a，b。a字符串代表手中牌，b字符串代表出的牌。</span><br></pre></td></tr></table></figure>

<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">压过输出YES 否则NO。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12233445566677</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>我的暴力解法，拿到题首先想到的方法，判断5种打出的牌的情况，再讨论手上的牌是否存在大于打出牌的情况。</p>
<p>这里有一个问题，就是输入是字符串，在c++中，<code>string</code>和<code>char</code>转<code>int</code>有以下两种常用方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#方法<span class="number">1</span></span><br><span class="line"><span class="type">char</span> c1=<span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"><span class="type">int</span> a=c1-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctring&gt;</span></span></span><br><span class="line">stirng s1=<span class="string">&#x27;1245&#x27;</span></span><br><span class="line"><span class="type">int</span> a=<span class="built_in">stoi</span>(s1);</span><br></pre></td></tr></table></figure>

<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/stol">stoi的官方文档</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> string&amp; s1,<span class="type">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s2.<span class="built_in">length</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="built_in">stoi</span>(s2))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]-<span class="string">&#x27;0&#x27;</span>&gt;=s2[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&amp;&amp;s1[i+<span class="number">1</span>]==s1[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]-<span class="string">&#x27;0&#x27;</span>&gt;=s2[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&amp;&amp;s1[i+<span class="number">1</span>]==s1[i]&amp;&amp;s1[i+<span class="number">2</span>]==s1[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]-<span class="string">&#x27;0&#x27;</span>&gt;=s2[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>&amp;&amp;s1[i+<span class="number">1</span>]==s1[i]&amp;&amp;s1[i+<span class="number">2</span>]==s1[i]&amp;&amp;s1[i+<span class="number">3</span>]==s1[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">length</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i]-<span class="string">&#x27;0&#x27;</span>&gt;=s2[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span></span><br><span class="line">                &amp;&amp;s1[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>==s1[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span></span><br><span class="line">                &amp;&amp;s1[i+<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>==s1[i+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span></span><br><span class="line">                &amp;&amp;s1[i+<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>==s1[i+<span class="number">2</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span></span><br><span class="line">                &amp;&amp;s1[i+<span class="number">4</span>]-<span class="string">&#x27;0&#x27;</span>==s1[i+<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1,s2;<span class="comment">//s1为手持牌，s2为打出的牌</span></span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Compare</span>(s1,s2))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>在牛客网上看到的解法，很简单只用了几十行代码。</p>
<p><strong>还没看懂，等待学习！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    string a,b;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl; <span class="comment">//已经最大了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                b[i]=b[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a.<span class="built_in">find</span>(b)!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;   <span class="comment">//叠牌</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            string c=a;</span><br><span class="line">            <span class="built_in">unique</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(c.<span class="built_in">find</span>(b)!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;  <span class="comment">//顺子</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>求哈夫曼树最短路径长度</title>
    <url>/2021/03/09/%E6%B1%82%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和的最小值。</p>
<span id="more"></span>

<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出权值。</span><br></pre></td></tr></table></figure>

<p><strong>输入样例</strong></p>
<blockquote>
<p>5</p>
<p>1 2 2 5 9</p>
</blockquote>
<p>输出样例</p>
<blockquote>
<p>37</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>解题关键是权值的求法：赫夫曼树的带权路径之和为各叶子节点的权值与路径长度（层次数减一或从根节点到达叶子节点路径上的非叶子节点的个数）之积的和。在构造赫夫曼树时，非叶子节点也会带有权值（为其子节点的权值之和），当加上一个非叶子节点的权值时相当于加上以其为根节点的子树的所有叶子节点的权值。而加上从根节点到叶子节点路径上的非叶子节点权值，就包含了该叶子节点的带权路径长度。所以<strong>带权路径之和即为所有非叶子节点的权值之和</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//构造小顶堆，为得到当前叶结点序列中的最小值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; hafman;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,num,totalkey=<span class="number">0</span>; <span class="comment">//n为叶结点树木，num为输入值，totalkey存储叶结点权值和</span></span><br><span class="line">    <span class="type">int</span> leaf1,leaf2;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> i=n;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        hafman.<span class="built_in">push</span>(num);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//构造哈夫曼树，当有多余2个叶结点时可以继续构造</span></span><br><span class="line">    <span class="keyword">while</span>(hafman.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//将堆顶的两个最小叶结点弹出构造一个父结点</span></span><br><span class="line">        leaf1=hafman.<span class="built_in">top</span>();</span><br><span class="line">        hafman.<span class="built_in">pop</span>();</span><br><span class="line">        leaf2=hafman.<span class="built_in">top</span>();</span><br><span class="line">        hafman.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">//将新结点作为叶子结点放进堆中，并重新进行排序</span></span><br><span class="line">        hafman.<span class="built_in">push</span>(leaf1+leaf2);</span><br><span class="line">      <span class="comment">//关键步骤</span></span><br><span class="line">        totalkey+=leaf1+leaf2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;totalkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>沉默的大多数</title>
    <url>/2021/03/22/%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业设计-基于安卓系统的设备管理测试软件</title>
    <url>/2021/04/06/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>测试系统管理包括测试系统的配置管理、软件版本管理和运行管理等。分析Android系统下测试系统管理APP的需求，掌握Android系统开发环境及相关开发技术，设计并实现Android系统下测试系统管理APP。</p>
<span id="more"></span>

<h2 id="设备启动步骤"><a href="#设备启动步骤" class="headerlink" title="设备启动步骤"></a>设备启动步骤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改 ttt里的IP地址为计算机的地址78</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录主板</span></span><br><span class="line">cd  u</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g  下载，-r 下载时间不受限制</span></span><br><span class="line">tftp -g -r ttt  192.168.0.78</span><br><span class="line">sh ttt</span><br></pre></td></tr></table></figure>

<ol>
<li>使用tftp将ttt.sh传输到设备的<code>/u</code>目录中，执行ttt。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ttt</span></span><br><span class="line">tftp -g -r pardus 192.168.0.36</span><br><span class="line">tftp -g -r pardus.ko 192.168.0.36</span><br><span class="line">tftp -g -r version 192.168.0.36</span><br><span class="line">tftp -g -r start.sh 192.168.0.36</span><br><span class="line">chmod +x start.sh</span><br><span class="line">chmod +x pardus</span><br><span class="line">chmod +x pardus.ko</span><br><span class="line">ls &gt;disable</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h4 id="执行ttt的过程中将执行文件pardus，pardus-ko，version，start-sh通过tftp传输到设备中。"><a href="#执行ttt的过程中将执行文件pardus，pardus-ko，version，start-sh通过tftp传输到设备中。" class="headerlink" title="执行ttt的过程中将执行文件pardus，pardus.ko，version，start.sh通过tftp传输到设备中。"></a>执行ttt的过程中将执行文件<code>pardus</code>，<code>pardus.ko</code>，<code>version</code>，<code>start.sh</code>通过tftp传输到设备中。</h4></li>
<li><p>初始化工作由<code>start.sh</code>完成，<code>ustart.h</code>可以完成不同参数的初始化工作（需要实现软件在ui设置初始化的参数）</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">start.sh</span></span><br><span class="line">ifconfig eth1 down</span><br><span class="line">ifconfig eth1 hw ether 40:3D:5F:20:00:30</span><br><span class="line">ifconfig eth1 up</span><br><span class="line">ifconfig eth1 192.168.0.80</span><br><span class="line">ifconfig eth0 192.168.1.80</span><br><span class="line">ifconfig eth0 down</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">每次启动初始化将version字段+1</span></span><br><span class="line">cat /u/version | while read var </span><br><span class="line">do</span><br><span class="line">var=`expr $var + 1`</span><br><span class="line">echo $var&gt;/u/version</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">sleep 2</span><br><span class="line">insmod /u/pardus.ko</span><br><span class="line">/u/pardus</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ustart.sh</span></span><br><span class="line">ifconfig eth1 down</span><br><span class="line">ifconfig eth1 hw ether 40:3D:5F:20:05:72</span><br><span class="line">ifconfig eth1 up</span><br><span class="line">ifconfig eth1 192.168.0.72</span><br><span class="line">ifconfig eth0 192.168.1.72</span><br><span class="line">ifconfig eth0 down</span><br><span class="line"></span><br><span class="line">cat /u/version | while read var </span><br><span class="line">do</span><br><span class="line">var=`expr $var + 1`</span><br><span class="line">echo $var&gt;/u/version</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">sleep 2</span><br><span class="line">insmod /u/pardus.ko</span><br><span class="line">/u/pardus -g 80000/0</span><br><span class="line">sleep 1</span><br><span class="line">/u/pardus</span><br></pre></td></tr></table></figure>



<h2 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h2><ol>
<li>初始化</li>
</ol>
<p><strong>参数</strong>有哪些？从设备中传调整好参数的ttt和start</p>
<ul>
<li>从安卓设备中将几个配置文件传到待测试设备中  ？？？<strong>怎么传送</strong>用<strong>ftp</strong>协议</li>
<li><code>start.sh</code>中的参数需要修改设备以太网接口的mac地址和ip地址</li>
</ul>
<ol start="2">
<li>升级</li>
</ol>
<p><del>升级需要改变什么？</del></p>
<p>需要更新<strong>pardus</strong>和<strong>pardus.ko</strong></p>
<ol start="3">
<li>显示设备属性</li>
</ol>
<p>cpu情况，内存情况，当前版本，ip地址等等信息。</p>
<p>使用top等命令，进行正则模式匹配得到对应系统信息，传至安卓设备中，形成设备信息，需要定期刷新？</p>
<ol start="4">
<li><p>输出日志信息</p>
<p><code>pardus</code>会定期输出日志，需要将日志信息采集到安卓软件中</p>
</li>
</ol>
<h2 id="实现方法-二选一"><a href="#实现方法-二选一" class="headerlink" title="实现方法(二选一)"></a>实现方法(二选一)</h2><ol>
<li>在安卓端实现一个talnet连接功能的软件，将所有脚本的命令按功能需求执行。<code>start.sh</code>还是需要传送过去。</li>
<li>在安卓端用tftp传输脚本文件到设备中，根据需要设置的参数修改脚本文件，然后执行脚本文件。</li>
</ol>
<p>看起来第一种实现方法比较好</p>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>linux 安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>第k小的数</title>
    <url>/2021/03/10/%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>查找一个数组的第K小的数，注意同样大小算一样大。 如 2 1 3 4 5 2 第三小数为3。</p>
<span id="more"></span>

<p><strong>输入描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入有多组数据。</span><br><span class="line">每组输入n，然后输入n个整数(1&lt;=n&lt;=1000)，再输入k。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出第k小的整数。</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 1 3 5 2 2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<p><a href="javascript:void(0);"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>先排序，在找到第k小的数，对于大小相同的数由于已经完成了排序，所以遇到相同的数用一个while循环不断跳过就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> flag=a[low],i=low,j=high;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=flag&amp;&amp;j&gt;i)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=flag&amp;&amp;j&gt;i)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[j],a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp=a[i];</span><br><span class="line">    a[i]=flag;</span><br><span class="line">    a[low]=temp;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,low,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,low+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,num,k;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//找到第k小的数</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i+<span class="number">1</span>]==a[i])</span><br><span class="line">            i++;</span><br><span class="line">        k--;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><p>用空间换时间，设置一个计数数组<code>count</code>,将输入数据<code>i</code>的位置的<code>count[i]</code>的数值设为1，寻找第k小的数就变成了在<code>count</code>中寻找第k个值为1的数组元素的下标大小，这样的时间复杂度仅有O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,num,k;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        count[num]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">while</span>(count[i]!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵n次幂</title>
    <url>/2021/03/12/%E7%9F%A9%E9%98%B5n%E6%AC%A1%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个n*n的矩阵，求该矩阵的k次幂，即P^k。</p>
<span id="more"></span>

<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行：两个整数n（2&lt;=n&lt;=10）、k（1&lt;=k&lt;=5），两个数字之间用一个空格隔开，含义如上所示。</span><br><span class="line">接下来有n行，每行n个正整数，其中，第i行第j个整数表示矩阵中第i行第j列的矩阵元素Pij且（0&lt;=Pij&lt;=10）。另外，数据保证最后结果不会超过10^8。</span><br></pre></td></tr></table></figure>

<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于每组测试数据，输出其结果。格式为：</span><br><span class="line">n行n列个整数，每行数之间用空格隔开，注意，每行最后一个数后面不应该有多余的空格。</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 2</span><br><span class="line">9 8</span><br><span class="line">9 3</span><br><span class="line">3 3</span><br><span class="line">4 8 4</span><br><span class="line">9 3 0</span><br><span class="line">3 5 7</span><br><span class="line">5 2</span><br><span class="line">4 0 3 0 1</span><br><span class="line">0 0 5 8 5</span><br><span class="line">8 9 8 5 3</span><br><span class="line">9 6 1 7 8</span><br><span class="line">7 2 5 7 3</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">153 96</span><br><span class="line">108 81</span><br><span class="line">1216 1248 708</span><br><span class="line">1089 927 504</span><br><span class="line">1161 1151 739</span><br><span class="line">47 29 41 22 16</span><br><span class="line">147 103 73 116 94</span><br><span class="line">162 108 153 168 126</span><br><span class="line">163 67 112 158 122</span><br><span class="line">152 93 93 111 97</span><br></pre></td></tr></table></figure>



<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用一个函数计算矩阵乘积的结果，再循环n次即为n次幂的结果。</p>
<p><strong>遇到的问题</strong>：</p>
<p>之前曾经遇到过，大半年没碰过代码了生疏了忘了，关于c语言中把二重数组作为函数参数，必须要指明行数，这是为啥呢？</p>
<p>若是一维数组可以直接将<code>int* a</code>作为参数传递，因为这就直接指明了数组a的地址，而当使用多维数组时，若不指明每行的元素个数，编译器就无法得到每个元素的地址，也就无法完成编译，因此n维数组作为函数参数时需要指明n-1层的元素个数</p>
<p><code>int *a[n-1][n-2]...[1]</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="comment">//计算矩阵相乘的结果，存入第一个数组中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixMul</span><span class="params">(<span class="type">int</span> a[N][N],<span class="type">int</span> b[N][N],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//O(n3)复杂度的求矩阵乘积结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                result[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果拷贝入第一个参数的数组中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a,result,<span class="built_in">sizeof</span> (result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//记录数组个数，数组维数，求的幂次数</span></span><br><span class="line">    <span class="type">int</span> n,dimention,power;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;dimention;</span><br><span class="line">        cin&gt;&gt;power;</span><br><span class="line">        <span class="type">int</span> a[N][N],result[N][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dimention;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;dimention;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;a[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(result,a,<span class="built_in">sizeof</span> (a));</span><br><span class="line">        <span class="comment">//求power次幂</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;power;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MatrixMul</span>(result,a,dimention);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dimention;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;dimention;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;result[j][k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研复试机试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2022/11/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="LeetCode笔记之滑动窗口题目"><a href="#LeetCode笔记之滑动窗口题目" class="headerlink" title="LeetCode笔记之滑动窗口题目"></a>LeetCode笔记之滑动窗口题目</h1><h2 id="滑动窗口一般做法"><a href="#滑动窗口一般做法" class="headerlink" title="滑动窗口一般做法"></a>滑动窗口一般做法</h2><span id="more"></span>

<p>滑动窗口题目常常在子数组、子字符串题目中出现，并且加以前缀最大、最小，目标是找到符合条件的最大最小子组合。</p>
<p>接下来就开始介绍数组操作中另一个重要的方法：<strong>滑动窗口</strong>。</p>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p><a href="https://postimg.cc/18y7WVns"><img src="https://i.postimg.cc/jSfVSzRw/slidingwindow.png" alt="slidingwindow.png"></a></p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。</p>
<p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>首先用两个指针<code>i</code>、<code>j</code>表示滑动窗口的的左窗口和右窗口，在一个for循环中，<strong>首先完成左窗口的左移</strong>，一般是判断当前窗口不符合条件再通过缩小窗口的左边界使窗口符合条件。再将右边界<code>j</code>++操作，扩充当前窗口大小。</p>
<h2 id="题目参考"><a href="#题目参考" class="headerlink" title="题目参考"></a>题目参考</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<p>一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！</p>
<p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p>
<p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p>
<p>时间复杂度：O(n) 遍历一遍字符串</p>
<p>空间复杂度： O(n) 窗口大小，最坏情况下窗口大小等于整个字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Mid)</span></span> lengthOfLongestSubString(s <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">	m.Name = <span class="string">&quot;最大不重复子串&quot;</span></span><br><span class="line">    <span class="comment">//使用一个map保存已经出现的字符</span></span><br><span class="line">	substringMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> maxLen <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">//缩减左边界，若当前右边界的字符已经在map中 存在则说明</span></span><br><span class="line">        <span class="comment">//至少有一个相同字符在窗口中，此时不断缩减左边界以确保窗口中没有重复字符</span></span><br><span class="line">		<span class="keyword">for</span> substringMap[s[j]] == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="built_in">delete</span>(substringMap, s[i])</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取最大长度</span></span><br><span class="line">		maxLen = <span class="type">int</span>(math.Max(<span class="type">float64</span>(maxLen), <span class="type">float64</span>(j-i+<span class="number">1</span>)))</span><br><span class="line">        <span class="comment">//扩充右边界</span></span><br><span class="line">		substringMap[s[j]] = <span class="number">1</span></span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案</p>
</blockquote>
<p>实例</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC</span><br></pre></td></tr></table></figure>
</blockquote>
<p>本题使用滑动窗口算法，用一个map<code>[byte]int</code>存储t字符串中各个字母出现的次数。右窗口扩充，获取覆盖字符。左窗口缩减，在符合覆盖字符的条件下尽量缩小窗口长度。在for循环中，窗口右边界j每次+1并且判断当前边界的字符是否在map中，如果在map中存在，就将map中对应的次数减一，说明当前窗口已经存在一个需要的字符。而左窗口的缩减就在每次右窗口扩充后，用于实例化的函数<code>check</code>判断是否满足条件，然后在满足条件的情况下尽量缩减左窗口以获得对应的最小覆盖字串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	minLength := math.MaxInt</span><br><span class="line">	subStringMap := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">		subStringMap[<span class="type">byte</span>(v)]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断当前窗口内是否已包含需要的字串</span></span><br><span class="line">	check := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> subStringMap &#123;</span><br><span class="line">			<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; j &lt; <span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := subStringMap[s[j]]; ok &#123;</span><br><span class="line">			subStringMap[s[j]]--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> check() &amp;&amp; i &lt;= j &#123;</span><br><span class="line">			<span class="keyword">if</span> j-i+<span class="number">1</span> &lt; minLength &#123;</span><br><span class="line">				result = s[i : j+<span class="number">1</span>]</span><br><span class="line">				minLength = j - i + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> _, ok := subStringMap[s[i]]; ok &#123;</span><br><span class="line">				subStringMap[s[i]]++</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：本体遇到一个超时样例，长达几万个字符，在使用make初始化map切片时会报超时，而直接用var对变量进行初始化时就不会超时。使用benchmark工具对两种情况的初始化进行定量分析发现当使用make创造切片时会长5ms时间，非常疑惑。</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮 - 力扣（LeetCode）</a></p>
<blockquote>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	fruitMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; j &lt; <span class="built_in">len</span>(fruits); j++ &#123;</span><br><span class="line">		<span class="comment">//如果出现新品类水果</span></span><br><span class="line">		fruitMap[fruits[j]]++</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(fruitMap) == <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> result &lt; j-i+<span class="number">1</span> &#123;</span><br><span class="line">				result = j - i + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(fruitMap) == <span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := fruitMap[fruits[i]]; ok &#123;</span><br><span class="line">				<span class="keyword">if</span> fruitMap[fruits[i]]--; fruitMap[fruits[i]] == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="built_in">delete</span>(fruitMap, fruits[i])</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(fruitMap)==<span class="number">1</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> j - i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/shortest-supersequence-lcci/">面试题 17.18. 最短超串 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列 - 力扣（LeetCode）</a></p>
<p><a href="https://leetcode.cn/problems/VabMRr/">剑指 Offer II 015. 字符串中的所有变位词 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2022/11/17/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h1 id="LeetCode笔记之二分法题目"><a href="#LeetCode笔记之二分法题目" class="headerlink" title="LeetCode笔记之二分法题目"></a>LeetCode笔记之二分法题目</h1><h2 id="二分法一般做法"><a href="#二分法一般做法" class="headerlink" title="二分法一般做法"></a>二分法一般做法</h2><span id="more"></span>

<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<h3 id="二分法第一种做法"><a href="#二分法第一种做法" class="headerlink" title="二分法第一种做法"></a>二分法第一种做法</h3><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p><a href="https://postimg.cc/RWvC8Q4d"><img src="https://i.postimg.cc/2SZq12ts/erfen1.jpg" alt="erfen1.jpg" style="zoom:200%;" /></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.size() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二分法第二种做法"><a href="#二分法第二种做法" class="headerlink" title="二分法第二种做法"></a>二分法第二种做法</h3><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<p><a href="https://postimg.cc/75DHJ1R7"><img src="https://i.postimg.cc/y83k5vXf/erfen2.jpg" alt="erfen2.jpg" style="zoom:200%;" /></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.size(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找重点概括"><a href="#二分查找重点概括" class="headerlink" title="二分查找重点概括"></a>二分查找重点概括</h3><p>写成 while(left &lt; right) ，退出循环的时候有 left == right 成立，好处是：不用判断应该返回 left 还是 right；<br>区间 [left..right] 划分只有以下两种情况：<br>分成 [left..mid] 和 [mid + 1..right]，分别对应 right = mid 和 left = mid + 1；<br>分成 [left..mid - 1] 和 [mid..right]，分别对应 right = mid - 1 和 left = mid，这种情况下。需要将 int mid = (left + right) / 2 改成 int mid = (left + right + 1) / 2，否则会出现死循环，这一点不用记，出现死循环的时候，把 left 和 right 的值打印出来看一下就很清楚了；<br>退出循环 left == right，如果可以确定区间 [left..right] 一定有解，直接返回 left 就可以，否则还需要对 left 这个位置单独做一次判断；<br>始终保持不变的是：在区间 [left..right] 里查找目标元素</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<p>简单的二分法，关键是当出现不在数组中的元素是，如何找到该元素在数组中的位置。在二分法中，如果最后没找到对应的元素，<code>i</code>、<code>j</code>所在的位置即为该元素应该存在的位置，因为二分法是不断根据位置进行排除的算法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i, j, mid := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt;= j &#123;</span><br><span class="line">		mid = i + (j-i)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			j = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			i = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/?favorite=2cktkvj">4. 寻找两个正序数组的中位数 - 力扣（LeetCode）</a><strong>Hard</strong></p>
<blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
</blockquote>
<p>看到时间复杂度为O(logn)就能猜到使用的方法大概率为递归、二分法中一种。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    l1 := <span class="built_in">len</span>(nums1)</span><br><span class="line">	l2 := <span class="built_in">len</span>(nums2)</span><br><span class="line">	<span class="comment">//中位数在两数组合并后的mid位置</span></span><br><span class="line">	mid1 := (l1 + l2 + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	mid2 := (l1 + l2 + <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> (findMedian(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, mid1) + findMedian(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, mid2))/<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedian</span><span class="params">(nums1 []<span class="type">int</span>, left1 <span class="type">int</span>, nums2 []<span class="type">int</span>, left2 <span class="type">int</span>, mid <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left1 &gt;= <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(nums2[left2+mid<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> left2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(nums1[left1+mid<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mid == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Min(<span class="type">float64</span>(nums1[left1+mid<span class="number">-1</span>]), <span class="type">float64</span>(nums2[left2+mid<span class="number">-1</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> nums1Mid, nums2Mid <span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> mid/<span class="number">2</span> &lt; <span class="built_in">len</span>(nums1)-left1+<span class="number">1</span> &#123;</span><br><span class="line">		nums1Mid = nums1[left1+mid/<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nums1Mid = math.MaxInt</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mid/<span class="number">2</span> &lt; <span class="built_in">len</span>(nums2)-left2+<span class="number">1</span> &#123;</span><br><span class="line">		nums2Mid = nums2[left2+mid/<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nums2Mid = math.MaxInt</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nums1Mid &gt;= nums2Mid &#123;</span><br><span class="line">		<span class="keyword">return</span> findMedian(nums1, left1, nums2, left2+mid/<span class="number">2</span>, mid-mid/<span class="number">2</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> findMedian(nums1, left1+mid/<span class="number">2</span>, nums2, left2, mid-mid/<span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
</blockquote>
<p>实例1：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我的想法：二分法，找到等于target的值，假设第一个找到的target的值的位置是mid，此时再递归调用<code>subRange</code>在左右两个区间里找到其他的target，然后将结果合并即可，这个做法的难点在于边界问题。当left和right仅仅只差1时，mid将会与left、right重合。需要仔细考虑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> j &lt; i &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	left, right := subRange(nums, target, i, j)</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subRange</span><span class="params">(nums []<span class="type">int</span>, target, left, right <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">//当二分分出的left大于right时，递归结束</span></span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[left] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> left, right</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//防止left、right超出范围</span></span><br><span class="line">	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">	<span class="comment">//二分开始</span></span><br><span class="line">	<span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">		<span class="keyword">return</span> subRange(nums, target, left, mid<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">		<span class="keyword">return</span> subRange(nums, target, mid+<span class="number">1</span>, right)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//mid==left时，说明right-left=1，right和left相邻</span></span><br><span class="line">		<span class="comment">//此时为了防止mid+1、mid-1越界，手动判断情况</span></span><br><span class="line">		<span class="keyword">if</span> mid == left &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[right] == target &#123;</span><br><span class="line">				<span class="keyword">return</span> left, right</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> left, left</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当nums[mid]=target时，说明target分布在mid两侧，此时分别在两侧寻找target的左右边界</span></span><br><span class="line">		i, _ := subRange(nums, target, left, mid<span class="number">-1</span>)</span><br><span class="line">		_, j := subRange(nums, target, mid+<span class="number">1</span>, right)</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">-1</span> &amp;&amp; j == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid, mid</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid, j</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> i, mid</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i, j</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还没解决的想法：根据<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a>的想法，找到target和target+1在数组中的位置，就能找到target的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    leftmost := sort.SearchInts(nums, target)</span><br><span class="line">    <span class="keyword">if</span> leftmost == <span class="built_in">len</span>(nums) || nums[leftmost] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rightmost := sort.SearchInts(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;leftmost, rightmost&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<p>实例1：</p>
<blockquote>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
</blockquote>
<p>动态规划，具体看注释</p>
<p><code>dp[i]</code>代表长度以<code>i</code>为结尾的子数组的最长递增子序列长度，其值应该等于从0到j的子数组的最长递增子序列的最大值+1，此时nums[j]&lt;nums[i]。因为如果第i个元素的值小于第j个元素的值，则说明以i结尾构不成最长子序列，只能让最长长度为1.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">//动态规划数组，dp[i]代表从0到i的数组切片的最长递增子序列</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	result := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">		maxDp := <span class="number">0</span></span><br><span class="line">		<span class="comment">//转移方程dp[i]=max(dp[j])+1,0&lt;=j&lt;i,nums[i]&gt;nums[j]</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] &gt; nums[j] &#123;</span><br><span class="line">				maxDp = <span class="type">int</span>(math.Max(<span class="type">float64</span>(maxDp), <span class="type">float64</span>(dp[j])))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i] = maxDp + <span class="number">1</span></span><br><span class="line">		result = <span class="type">int</span>(math.Max(<span class="type">float64</span>(result), <span class="type">float64</span>(dp[i])))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
</blockquote>
<p>测试样例：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 10^5</li>
<li>nums.length == n + 1</li>
<li>1 &lt;= nums[i] &lt;= n</li>
<li>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</li>
</ul>
<p>二分法解法，因为数组<code>nums</code>的条件为长度为n+1，而<code>nums</code>中的数字出现的范围也是n+1，这就说明数字必须覆盖<code>0~n-i</code>的范围，<code>i</code>为重复出现的数字数。这样就有了使用二分法寻找的几乎，这类似于二分法寻找中位数。比如测试样例中的[1,3,4,2,2]，就覆盖了0<del>4的范围，而在[0,<code>len(nums)</code>]的区间0</del>5上，中位数应该为(0+5)/2为2，而在<code>nums</code>数组中0<del>2的数字有3个这就说明重复的数组绝对出现在0</del>2的范围里。这样就可以使用二分法的方法判断是否重复数组出现的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	left, right, mid, count := <span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		count = <span class="number">0</span></span><br><span class="line">		mid = (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="comment">//获得中位数范围的计数</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			<span class="keyword">if</span> v &lt;= mid &#123;</span><br><span class="line">				count++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果计数小于等于mid则说明范围0~mid里的数字没有重复数字</span></span><br><span class="line">		<span class="keyword">if</span> count &lt;= mid &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">         <span class="comment">//反之说明0~mid范围里有重复数字，将处理范围放置到0~mid   </span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题还有一种原地哈希的方法，由于这题要求的空间为O(1)，所以不能使用哈希表，但是我们可以使用输入数组代替哈希表。比如当遍历到<code>i</code>时，为了表示<code>nums[i]</code>已经出现过，我们可以让<code>nums[nums[i]]</code>的值转为负数，这就说明此值已经出现过。这就发挥了哈希表的作用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		p:=<span class="type">int</span>(math.Abs(<span class="type">float64</span>(v)))</span><br><span class="line">		<span class="keyword">if</span> nums[p]&lt;<span class="number">0</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> p</span><br><span class="line">		&#125;</span><br><span class="line">		nums[p]*=<span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针法</title>
    <url>/2022/11/22/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/</url>
    <content><![CDATA[<h1 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h1><span id="more"></span>

<h2 id="双指针一般做法"><a href="#双指针一般做法" class="headerlink" title="双指针一般做法"></a>双指针一般做法</h2><p>双指针法是一种通过一次for循环移动两个指针以达到算法目的的算法。在数组、链表、字符串中都经常使用这种方法，这种题目一般没有固定做法，关键是双指针的移动方法，下面给出一些题目。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p><a href="https://postimg.cc/XGr7RY7c"><img src="https://i.postimg.cc/rmJ0tDBb/twopointer.gif" alt="twopointer.gif" style="zoom:200%;" /></a></p>
<p>使用双指针遍历，一个慢指针指向新数组元素应该在的位置，一个快指针指向原数组元素的位置，关键在于快指针碰到需删除元素时的情况，此时不做任何操作仅增加快指针计数即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="type">int</span>, val <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[j] != val &#123;</span><br><span class="line">			i++</span><br><span class="line">			nums[i] = nums[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<p>测试用例</p>
<blockquote>
<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>这题和27的解法几乎一毛一样，使用两个指针遍历数组，一个慢指针<code>i</code>作新数组的下标，每次遍历得到的重复数字放在i的位置。一个快指针遍历整个数组。当遇到新的不等于当前i位置的数时，将nums[i++]赋值为nums[j]，就可以保证数组前面不重复。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] != nums[j] &#123;</span><br><span class="line">			i++</span><br><span class="line">			nums[i] = nums[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//因为子数组的最长下标等于长度等于</span></span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II - 力扣（LeetCode）</a></p>
<blockquote>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sb, count := []<span class="type">byte</span>(s), <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(sb); j++ &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">if</span> count == k &#123;</span><br><span class="line">			reverse(sb, j-k+<span class="number">1</span>, j)</span><br><span class="line">			count = -k</span><br><span class="line">			<span class="comment">//最后字符串尾部不够k个字符的情况</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="built_in">len</span>(sb)<span class="number">-1</span> &#123;</span><br><span class="line">			reverse(sb, j-count+<span class="number">1</span>, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(sb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="type">byte</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, j := left, right; i &lt; j; &#123;</span><br><span class="line">		temp := s[i]</span><br><span class="line">		s[i] = s[j]</span><br><span class="line">		s[j] = temp</span><br><span class="line">		i++</span><br><span class="line">		j--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a></p>
<blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
</blockquote>
<p>示例1</p>
<p><a href="https://postimg.cc/4K3qWH6T">Circle-List.png</a></p>
<p><a href="https://postimg.cc/dk76LKJs"><img src="https://i.postimg.cc/k4spYnZb/circularlinkedlist.png" alt="circularlinkedlist.png" style="zoom:150%;" /></a></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>非常经典的环形链表问题，可以将这个问题分解为两个问题来求解，1是如何证明一个链表是有环的，二是怎么在一个有环的链表中找到这个环开始的位置</p>
<ol>
<li><strong>如何判断链表是有环的</strong></li>
</ol>
<p>这是一个经典的快慢指针问题，随后，<code>slow</code> 指针每次向后移动一个位置，而 <code>fast</code> 指针向后移动两个位置。如果链表中存在环，则 <code>fast</code> 指针最终将再次与 <code>slow</code> 指针在环中相遇。</p>
<p>如下图所示，设链表中环外部分的长度为 a。<code>slow</code> 指针进入环后，又走了 b 的距离与 <code>fast </code>相遇。此时，<code>fast</code> 指针已经走完了环的 nn圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc</p>
<p>根据题意，任意时刻，<code>fast</code> 指针走过的距离都为 <code>slow</code> 指针的 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         倍。因此，我们有</p>
<p>a+(n+1)b+nc=2(a+b)⟹ a=c+(n-1)(b+c)    </p>
<p>有了 a=c+(n-1)(b+c)的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1圈的环长，恰好等于从链表头部到入环点的距离。</p>
<p><a href="https://postimg.cc/4K3qWH6T"><img src="https://i.postimg.cc/6QVK5dTT/Circle-List.png" alt="Circle-List.png" style="zoom:150%;" /></a></p>
<ol>
<li><strong>如果链表有环如何找到环开始的位置</strong></li>
</ol>
<p>根据上面的分析，如果链表已经有环，当快指针和慢指针相遇时，从链表起点到相遇位置的距离为a+b，此时让一个指针从链表起点开始，一个指针从相遇位置开始 ，两个指针向后移动，会在环的开始位置相遇。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	fastNode, slowNode := head, head</span><br><span class="line">	<span class="keyword">for</span> fastNode != <span class="literal">nil</span> &amp;&amp; fastNode.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		fastNode = fastNode.Next.Next</span><br><span class="line">		slowNode = slowNode.Next</span><br><span class="line">		<span class="comment">//如果快慢指针相遇</span></span><br><span class="line">		<span class="keyword">if</span> fastNode == slowNode &#123;</span><br><span class="line">			<span class="comment">//定义一个从头开始的新指针</span></span><br><span class="line">			MeetNode := head</span><br><span class="line">			<span class="comment">//不断循环让新指针和相遇位置的指针在环开始位置相遇</span></span><br><span class="line">			<span class="keyword">for</span> MeetNode != slowNode &#123;</span><br><span class="line">				MeetNode = MeetNode.Next</span><br><span class="line">				slowNode = slowNode.Next</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> MeetNode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种做法，从头到尾遍历链表。用一个哈希表来存储出现过的结点。如果出现一个节点已经在哈希表里了，就说明链表有环，且这个节点就是环开始的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    nodeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="type">bool</span>)</span><br><span class="line">    Node:=head</span><br><span class="line">    <span class="keyword">for</span> Node!=<span class="literal">nil</span>&amp;&amp;Node.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\n&quot;</span>,Node.Val)</span><br><span class="line">        <span class="keyword">if</span> _,ok:=nodeMap[Node];ok&#123;</span><br><span class="line">            <span class="keyword">return</span> Node</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nodeMap[Node]=<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        Node=Node.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<p>示例1</p>
<blockquote>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p>
</blockquote>
<p>解法1：</p>
<p>最蠢的哈希表法，边界问题难以掌控。首先使用两个for循环找到2个数字，再用哈希表寻找第三个可以和这两个数字和为0的数字。因为哈希表的键值为数组中的实际值。但是这样很难去除重复的三元组，花了很长时间解决这个问题，关键是对数组先进行排序，然后分别避免三元组中出现重复的元素，这样就可以解决重复的问题，具体方法见注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">//对元数据进行排序</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">//假设三元组元素是a、b、c</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//因为数组已经排好序了，所以相同的a元素一定连续排列，只要判断nums[i]!=nums[i-1]就可以排除相同的a元素</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//很核心的思想是当确定了a之后，b是变化的，并且每次只在a到b之间寻找c，可以有效避免重复问题</span></span><br><span class="line">		numsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">			<span class="comment">//对b去重，与对a去重同理，保证只对相同的a、b处理一次，为什么不能有3个相同的b，比如0，0，0</span></span><br><span class="line">			<span class="keyword">if</span> j &gt; i+<span class="number">2</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &amp;&amp; nums[j] == nums[j<span class="number">-2</span>] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//存在三元组</span></span><br><span class="line">			third := <span class="number">0</span> - nums[i] - nums[j]</span><br><span class="line">			<span class="comment">//判断当前三元组是否已经在结果中存在</span></span><br><span class="line">			<span class="keyword">if</span> cnt, ok := numsMap[third]; ok &amp;&amp; cnt &gt; <span class="number">0</span> &#123;</span><br><span class="line">				triple := []<span class="type">int</span>&#123;nums[i], nums[j], third&#125;</span><br><span class="line">				result = <span class="built_in">append</span>(result, triple)</span><br><span class="line">				<span class="comment">//这一步很关键，直接让c的map值变为0，这样可以保证不重复的c</span></span><br><span class="line">				numsMap[third] = <span class="number">0</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				numsMap[nums[j]]++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2：</p>
<p>双指针+哈希表的方法</p>
<p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p>
<p>时间复杂度：O(n^2)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum2</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">//假设得到的三元组为a，b，c</span></span><br><span class="line">	<span class="comment">//双指针法，一个for循环的指针i表示a，一个left=i+1表示b，right=len(nums)表示c</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="comment">//因为已经排序，如果a有重复的则去除连续的a</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//left、right分别从i+1、len-1的位置开始，向中间靠拢寻找和为0的三元组</span></span><br><span class="line">		<span class="keyword">for</span> left, right := i+<span class="number">1</span>, <span class="built_in">len</span>(nums); left &lt; right; &#123;</span><br><span class="line">			<span class="comment">//如果当前nums[left]+nums[right]+nums[i]和小于0则说明需要更大的数字，left左移获取更大的数字</span></span><br><span class="line">			<span class="comment">//如果当前nums[left]+nums[right]+nums[i]和大于0则说明需要更小的数字，right右移获取更大的数字</span></span><br><span class="line">			<span class="keyword">if</span> nums[left]+nums[right]+nums[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">				left++</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left]+nums[right]+nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">				right--</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="comment">//和为0时，将结果三元组添加到结果中</span></span><br><span class="line">			&#123;</span><br><span class="line">				result = <span class="built_in">append</span>(result, []<span class="type">int</span>&#123;nums[i], nums[left], nums[right]&#125;)</span><br><span class="line">				<span class="comment">//分别从左右两边去除相同的元素，以防出现重复三元组</span></span><br><span class="line">				<span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>] &#123;</span><br><span class="line">					left++</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>] &#123;</span><br><span class="line">					right--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//找到和为0的三元组分别将左右指针都向中考虑</span></span><br><span class="line">				left++</span><br><span class="line">				right--</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;= a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] == target<br>你可以按 任意顺序 返回答案 。</p>
</blockquote>
<p>这题和上一题的三数之和类似，但是变成了四个数，只要再多添加一个for循环就可以了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i]+nums[j] &gt; target &amp;&amp; nums[i]+nums[j] &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			left, right := j+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">			<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">				<span class="keyword">if</span> nums[i]+nums[j]+nums[left]+nums[right] &gt; target &#123;</span><br><span class="line">					right--</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[left]+nums[right] &lt; target &#123;</span><br><span class="line">					left++</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					result = <span class="built_in">append</span>(result, []<span class="type">int</span>&#123;nums[i], nums[j], nums[left], nums[right]&#125;)</span><br><span class="line">					<span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>] &#123;</span><br><span class="line">						left++</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>] &#123;</span><br><span class="line">						right--</span><br><span class="line">					&#125;</span><br><span class="line">					left++</span><br><span class="line">					right--</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<p>实例1</p>
<p><a href="https://postimg.cc/QBzx7ydC"><img src="https://i.postimg.cc/hjDJkFFL/remove-ex1.jpg" alt="remove-ex1.jpg"></a></p>
<blockquote>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p>
</blockquote>
<p>这题使用两个指针，一个快指针，一个慢指针，删除倒数第n个元素，其实就是让快指针比慢指针快n步，然后再同时向后遍历。当快指针到达队列尾的时候，慢指针指向的位置其实就是倒数第n个元素。这里为了能够删除头节点，需要虚拟一个头节点<code>bigHead</code>指向真实的头节点，否则不能完成删除头节点的操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于虚拟了一个头节点，所以实际的count长度为n+1</span></span><br><span class="line">count, bigHead := n+<span class="number">1</span>, &amp;ListNode&#123;</span><br><span class="line">	Val:  <span class="number">0</span>,</span><br><span class="line">	Next: head,</span><br><span class="line">&#125;</span><br><span class="line">slowNode, fastNode := bigHead, bigHead</span><br><span class="line"><span class="comment">//让快指针快n步</span></span><br><span class="line"><span class="keyword">for</span> count &gt; <span class="number">0</span> &amp;&amp; fastNode != <span class="literal">nil</span> &amp;&amp; fastNode.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">	fastNode = fastNode.Next</span><br><span class="line">	count--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时向后遍历寻找尾部节点</span></span><br><span class="line"><span class="keyword">for</span> fastNode != <span class="literal">nil</span> &amp;&amp; fastNode.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">	fastNode = fastNode.Next</span><br><span class="line">	slowNode = slowNode.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时候slowNode停在倒数第n个节点前，直接删除即可</span></span><br><span class="line">slowNode.Next = slowNode.Next.Next</span><br><span class="line"><span class="keyword">return</span> bigHead.Next</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
</blockquote>
<p><a href="https://postimg.cc/d7gsZdPg"><img src="https://i.postimg.cc/NMj5V7NG/160-statement.png" alt="160-statement.png" style="zoom:150%;" /></a></p>
<p>这题有个很坑的点，相交链表开始的条件是<code>nodeA=nodeB</code>，而不是<code>nodeA.Val=nodeB.Val</code>。即相交的是结点相等而不是值相等。</p>
<p>然后这题就没有什么难的了，因为这题就是获取两个链表的长度l1,l2，然后让长的链表截短l2-l1，从长度相等的地方开始，遍历到相交的地方开始即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    node1,node2:=headA,headB</span><br><span class="line">    len1,len2:=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> node1==<span class="literal">nil</span>||node2==<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> node1!=<span class="literal">nil</span>&#123;</span><br><span class="line">        len1++</span><br><span class="line">        node1=node1.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> node2!=<span class="literal">nil</span>&#123;</span><br><span class="line">        len2++</span><br><span class="line">        node2=node2.Next</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len1,len2:%d,%d\n&quot;</span>,len1,len1)</span><br><span class="line">    node1=headA</span><br><span class="line">    node2=headB</span><br><span class="line">    <span class="keyword">if</span> len1&gt;len2&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=len1-len2;i&gt;<span class="number">0</span>;i--&#123;</span><br><span class="line">            node1=node1.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=len2-len1;i&gt;<span class="number">0</span>;i--&#123;</span><br><span class="line">            node2=node2.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> node1!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> node1==node2&#123;</span><br><span class="line">            <span class="keyword">return</span> node1</span><br><span class="line">        &#125;</span><br><span class="line">        node1=node1.Next</span><br><span class="line">        node2=node2.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2022/11/28/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表题目"><a href="#链表题目" class="headerlink" title="链表题目"></a>链表题目</h1><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
<p>链表的入口节点称为链表的头结点也就是head。</p>
<span id="more"></span>

<h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a><strong>链表的类型</strong></h2><p><strong>单链表</strong></p>
<p><a href="https://postimg.cc/t78YDp3Y"><img src="https://i.postimg.cc/xT1Mfdqy/List.png" alt="List.png" style="zoom:200%;" /></a></p>
<p>双链表</p>
<p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p>循环链表</p>
<p>循环链表，顾名思义，就是链表首尾相连。</p>
<p>循环链表可以用来解决约瑟夫环问题</p>
<h2 id="链表题目-1"><a href="#链表题目-1" class="headerlink" title="链表题目"></a>链表题目</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p>
<blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
